import { initAppMenu } from "./AppMenu";
import {
  app,
  BrowserWindow,
  ipcMain,
  IpcMainEvent,
  MenuItemConstructorOptions,
  systemPreferences,
} from "electron";
import { Config, config } from "shared/config";
import contextMenu from "electron-context-menu";
import ElectronStore from "electron-store";
import { existsSync } from "fs";
import * as pty from "node-pty";

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  // eslint-disable-line global-require
  app.quit();
}

const accentColor = ["darwin", "win32"].includes(process.platform)
  ? systemPreferences.getAccentColor()
  : config.fallbackAccentColor;

let mainWindow: BrowserWindow;
let initialURLToHandle: string | undefined;

async function createWindow(): Promise<void> {
  // Register ourselves as a URL scheme handler
  app.setAsDefaultProtocolClient("overt");

  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 992,
    height: 600,
    minWidth: 450,
    minHeight: 400,

    webPreferences: {
      additionalArguments: [
        `Overt.accentColor=${accentColor}`,
        `Overt.cachePath=${Buffer.from(app.getPath("cache")).toString(
          "base64"
        )}`,
      ],
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },

    show: false,
  });

  // https://www.electronjs.org/docs/latest/api/browser-window#using-the-ready-to-show-event
  mainWindow.once("ready-to-show", () => {
    mainWindow.show();
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  mainWindow.webContents.on("did-finish-load", () => {
    if (initialURLToHandle) {
      // App was launched to handle a URL that we couldn't handle below,
      // since the main window wasn't initialized yet
      mainWindow.webContents.send("handle_url", initialURLToHandle);
    }
  });

  ipcMain.on("relaunch", () => {
    app.relaunch();
    app.quit();
  });

  const ptyProcess =
    process.platform === "win32"
      ? pty.spawn("powershell.exe", [], {
          cwd: process.env.HOMEPATH,
          env: {
            ...(process.env as { [key: string]: string }),
          },
        })
      : pty.spawn("/bin/sh", [], {
          name: "xterm-color",
          cols: 220,
          rows: 26,
          cwd: process.env.HOME,
          env: {
            ...process.env,
            PS1: `\r\n${Array.from(Array(220).keys())
              .map(() => "â”")
              .join("")}\r\n`,
            // Silence "move to zsh" suggestion on macOS 10.15+
            BASH_SILENCE_DEPRECATION_WARNING: "1",
          },
        });

  ipcMain.on("terminal.send", (event: IpcMainEvent, data: string) => {
    ptyProcess.write(data);
  });
  ptyProcess.onData((data: string) => {
    mainWindow.webContents.send("terminal.receive", data);
  });

  const store = new ElectronStore<Config>({
    defaults: {
      sendNativeNotifications: true,
      validateCodeSignatures: true,

      useSystemAccentColor: false,
      tintDarkBackgrounds: false,

      fullIndexIntervalDays: 3,

      homebrewPath: existsSync("/opt/homebrew/bin/brew")
        ? "/opt/homebrew"
        : "/usr/local",
    },
  });

  ipcMain.handle(
    "settings.set",
    (event: IpcMainEvent, key: keyof Config, value: any) => {
      store.set(key, value);
    }
  );
  ipcMain.handle("settings.get", (event: IpcMainEvent, key: keyof Config) => {
    return store.get(key);
  });
  for (const [key] of store) {
    store.onDidChange(key, () => {
      mainWindow.webContents.send(`settings.${key}.change`);
    });
  }

  let contextMenuItems: {
    items: (MenuItemConstructorOptions &
      ({ callback: string; args: any[] } | { type: "separator" }))[];
  } = { items: [] };

  ipcMain.handle(
    "contextmenu.set",
    (
      event: IpcMainEvent,
      items: (MenuItemConstructorOptions &
        ({ callback: string; args: any[] } | { type: "separator" }))[]
    ) => {
      contextMenuItems.items = items.map((item) => ({
        ...item,
        click() {
          if ("callback" in item) {
            mainWindow.webContents.send(
              `contextmenu.callback.${item.callback}`,
              ...item.args
            );
          }
        },
      }));

      setTimeout(() => (contextMenuItems.items = []), 100);
    }
  );

  contextMenu({
    menu: (actions) => [
      actions.separator(),
      actions.cut({}),
      actions.copy({}),
      actions.paste({}),
    ],
    prepend: () => contextMenuItems.items,
  });

  initAppMenu();
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// TODO: Windows code to prevent another instance from opening when a URL is handled
app.on("open-url", (event, url) => {
  if (mainWindow) {
    mainWindow.webContents.send("handle_url", url);
  } else {
    // We'll handle it above, once the main window has been initialized
    initialURLToHandle = url;
  }
});

// Quit when all windows are closed.
app.on("window-all-closed", () => {
  app.quit();
});
