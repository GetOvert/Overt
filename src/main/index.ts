import {
  app,
  BrowserWindow,
  ipcMain,
  IpcMainEvent,
  MenuItemConstructorOptions,
  systemPreferences,
} from "electron";
import contextMenu from "electron-context-menu";
import ElectronStore from "electron-store";
import { existsSync } from "fs";
import * as pty from "node-pty";

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  // eslint-disable-line global-require
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 992,
    height: 600,
    webPreferences: {
      additionalArguments: [
        `OpenStore.accentColor=${systemPreferences.getAccentColor()}`,
        `OpenStore.cachePath=${app.getPath("cache")}`,
      ],
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegrationInWorker: true,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();

  const ptyProcess = pty.spawn("/bin/sh", [], {
    name: "xterm-color",
    cols: 80,
    rows: 30,
    cwd: process.env.HOME,
    env: {
      ...process.env,
      PS1: "> ",
      BASH_SILENCE_DEPRECATION_WARNING: "1", // Silence "move to zsh" suggestion on macOS 10.15+
    },
  });

  ipcMain.on("terminal.send", (event: IpcMainEvent, data: string) => {
    ptyProcess.write(data);
  });
  ptyProcess.onData((data: string) => {
    mainWindow.webContents.send("terminal.receive", data);
  });

  type Config = {
    validateCodeSignatures: boolean;
    homebrewPath: string;
    sendNativeNotifications: boolean;
  };

  const store = new ElectronStore<Config>({
    defaults: {
      validateCodeSignatures: true,
      homebrewPath: existsSync("/opt/homebrew/bin/brew")
        ? "/opt/homebrew"
        : "/usr/local",
      sendNativeNotifications: true,
    },
  });

  ipcMain.handle(
    "settings.set",
    (event: IpcMainEvent, key: keyof Config, value: any) => {
      store.set(key, value);
    }
  );
  ipcMain.handle("settings.get", (event: IpcMainEvent, key: keyof Config) => {
    return store.get(key);
  });

  let contextMenuItems: {
    items: (MenuItemConstructorOptions & { callback: string; args: any[] })[];
  } = { items: [] };

  ipcMain.handle(
    "contextmenu.set",
    (
      event: IpcMainEvent,
      items: (MenuItemConstructorOptions & { callback: string; args: any[] })[]
    ) => {
      contextMenuItems.items = items.map((item) => ({
        ...item,
        click() {
          mainWindow.webContents.send(
            `contextmenu.callback.${item.callback}`,
            ...item.args
          );
        },
      }));

      setTimeout(() => (contextMenuItems.items = []), 100);
    }
  );

  contextMenu({
    menu: (actions) => [actions.separator(), actions.cut({}), actions.copy({}), actions.paste({})],
    prepend: () => contextMenuItems.items,
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed.
app.on("window-all-closed", () => {
  app.quit();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
